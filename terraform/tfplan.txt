data.aws_availability_zones.available: Reading...
module.ECR.aws_ecr_repository.this: Refreshing state... [id=mvarela-io/vaultwarden]
module.VPC.aws_vpc.this[0]: Refreshing state... [id=vpc-02e6278fee33b0e02]
module.EKS.data.aws_iam_policy_document.assume_workers: Reading...
module.EKS.data.aws_iam_policy_document.assume_workers: Read complete after 0s [id=2851119427]
data.aws_availability_zones.available: Read complete after 1s [id=us-east-1]
module.SUBNETS.aws_eip.nat[0]: Refreshing state... [id=eipalloc-0ab8debd8ed5fde4d]
module.VPC.aws_default_route_table.this[0]: Refreshing state... [id=rtb-084e0b770d3c01552]
module.VPC.aws_default_security_group.this[0]: Refreshing state... [id=sg-00972304c4f931772]
module.VPC.aws_internet_gateway.this[0]: Refreshing state... [id=igw-01c1a034c3952641d]
module.VPC.aws_default_network_acl.this[0]: Refreshing state... [id=acl-06cf513ca34b849fc]
module.SUBNETS.aws_subnet.private[2]: Refreshing state... [id=subnet-0b87fae3a859b1f9a]
module.SUBNETS.aws_route_table.private[0]: Refreshing state... [id=rtb-08635b7562b6580bf]
module.SUBNETS.aws_subnet.private[0]: Refreshing state... [id=subnet-0412d625c123ec2dc]
module.SUBNETS.aws_subnet.private[1]: Refreshing state... [id=subnet-019ad86490acf3d5f]
module.SG_EC2.aws_security_group.this[0]: Refreshing state... [id=sg-0c0c4fef402eaca3a]
module.SUBNETS.aws_subnet.public[0]: Refreshing state... [id=subnet-07fd473cc46171e18]
module.SUBNETS.aws_subnet.public[1]: Refreshing state... [id=subnet-0ebfd76d2d4526595]
module.SUBNETS.aws_subnet.public[2]: Refreshing state... [id=subnet-0c49c73494562c6c8]
module.SUBNETS.aws_route_table.public[0]: Refreshing state... [id=rtb-098362e0bff8e345d]
module.SG_EC2.aws_security_group_rule.ingress_with_cidr_blocks[0]: Refreshing state... [id=sgrule-3117217562]
module.SG_EC2.aws_security_group_rule.egress_with_cidr_blocks[0]: Refreshing state... [id=sgrule-2700379680]
module.SUBNETS.aws_route_table_association.private[1]: Refreshing state... [id=rtbassoc-034d1a1ff3f7c728c]
module.SUBNETS.aws_route_table_association.private[2]: Refreshing state... [id=rtbassoc-0fdaed405501511b3]
module.SUBNETS.aws_route_table_association.private[0]: Refreshing state... [id=rtbassoc-09495fe75b986b416]
module.SUBNETS.aws_network_acl.private[0]: Refreshing state... [id=acl-0a2c0cbdd58c21cb0]
module.SUBNETS.aws_route.public_internet_gateway[0]: Refreshing state... [id=r-rtb-098362e0bff8e345d1080289494]
module.SUBNETS.aws_nat_gateway.this[0]: Refreshing state... [id=nat-03463b36abe99aca1]
module.SUBNETS.aws_route_table_association.public[1]: Refreshing state... [id=rtbassoc-09846e761a151ff5a]
module.SUBNETS.aws_route_table_association.public[0]: Refreshing state... [id=rtbassoc-0e010cdec59807e19]
module.SUBNETS.aws_route_table_association.public[2]: Refreshing state... [id=rtbassoc-0e480a2ff79984fd5]
module.SUBNETS.aws_network_acl.public[0]: Refreshing state... [id=acl-02a52dfecb1eccc52]
module.SUBNETS.aws_network_acl_rule.private_inbound[0]: Refreshing state... [id=nacl-928977179]
module.SUBNETS.aws_network_acl_rule.private_outbound[0]: Refreshing state... [id=nacl-2269604692]
module.EC2_JENKINS_MASTER.aws_instance.this: Refreshing state... [id=i-029b502b35fd3248c]
module.SUBNETS.aws_route.private_nat_gateway[0]: Refreshing state... [id=r-rtb-08635b7562b6580bf1080289494]
module.EC2_JENKINS_AGENT.aws_instance.this: Refreshing state... [id=i-045a12012d1177c4d]
module.SUBNETS.aws_network_acl_rule.public_inbound[0]: Refreshing state... [id=nacl-2312869124]
module.SUBNETS.aws_network_acl_rule.public_outbound[0]: Refreshing state... [id=nacl-148071462]

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create
-/+ destroy and then create replacement

Terraform will perform the following actions:

  # module.CERTMANAGER.helm_release.this will be created
  + resource "helm_release" "this" {
      + atomic                     = false
      + chart                      = "cert-manager"
      + cleanup_on_fail            = false
      + create_namespace           = true
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = true
      + id                         = (known after apply)
      + lint                       = true
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "cert-manager"
      + namespace                  = "cert-manager"
      + recreate_pods              = true
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://charts.jetstack.io"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 300
      + values                     = []
      + verify                     = false
      + version                    = "v1.13.1"
      + wait                       = true
      + wait_for_jobs              = false

      + set {
          + name  = "installCRDs"
          + value = "true"
        }
    }

  # module.EC2_JENKINS_AGENT.aws_instance.this must be replaced
-/+ resource "aws_instance" "this" {
      ~ arn                                  = "arn:aws:ec2:us-east-1:878893543361:instance/i-045a12012d1177c4d" -> (known after apply)
      ~ associate_public_ip_address          = false -> true # forces replacement
      ~ availability_zone                    = "us-east-1a" -> (known after apply)
      ~ cpu_core_count                       = 1 -> (known after apply)
      ~ cpu_threads_per_core                 = 1 -> (known after apply)
      ~ disable_api_stop                     = false -> (known after apply)
      ~ disable_api_termination              = false -> (known after apply)
      ~ ebs_optimized                        = false -> (known after apply)
      - hibernation                          = false -> null
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      ~ iam_instance_profile                 = "ECRRegistryFullAccessEC2" -> (known after apply)
      ~ id                                   = "i-045a12012d1177c4d" -> (known after apply)
      ~ instance_initiated_shutdown_behavior = "stop" -> (known after apply)
      + instance_lifecycle                   = (known after apply)
      ~ instance_state                       = "stopped" -> (known after apply)
      ~ ipv6_address_count                   = 0 -> (known after apply)
      ~ ipv6_addresses                       = [] -> (known after apply)
      ~ monitoring                           = false -> (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      ~ placement_partition_number           = 0 -> (known after apply)
      ~ primary_network_interface_id         = "eni-051efec62f93cba47" -> (known after apply)
      ~ private_dns                          = "ip-192-168-48-165.ec2.internal" -> (known after apply)
      ~ private_ip                           = "192.168.48.165" -> (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      ~ secondary_private_ips                = [] -> (known after apply)
      ~ security_groups                      = [] -> (known after apply)
      + spot_instance_request_id             = (known after apply)
      - tags                                 = {
          - "Name" = "Jenkins-Agent"
        } -> null
      ~ tags_all                             = {
          - "Name"       = "Jenkins-Agent" -> null
            # (2 unchanged elements hidden)
        }
      ~ tenancy                              = "default" -> (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
        # (8 unchanged attributes hidden)

      ~ capacity_reservation_specification {
          ~ capacity_reservation_preference = "open" -> (known after apply)

          + capacity_reservation_target {
              + capacity_reservation_id                 = (known after apply)
              + capacity_reservation_resource_group_arn = (known after apply)
            }
        }

      ~ cpu_options {
          + amd_sev_snp      = (known after apply)
          ~ core_count       = 1 -> (known after apply)
          ~ threads_per_core = 1 -> (known after apply)
        }

      - credit_specification {
          - cpu_credits = "standard" -> null
        }

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + tags                  = (known after apply)
          + throughput            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      ~ enclave_options {
          ~ enabled = false -> (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + instance_market_options {
          + market_type = (known after apply)

          + spot_options {
              + instance_interruption_behavior = (known after apply)
              + max_price                      = (known after apply)
              + spot_instance_type             = (known after apply)
              + valid_until                    = (known after apply)
            }
        }

      ~ maintenance_options {
          ~ auto_recovery = "default" -> (known after apply)
        }

      ~ metadata_options {
          ~ http_endpoint               = "enabled" -> (known after apply)
          ~ http_protocol_ipv6          = "disabled" -> (known after apply)
          ~ http_put_response_hop_limit = 1 -> (known after apply)
          ~ http_tokens                 = "optional" -> (known after apply)
          ~ instance_metadata_tags      = "disabled" -> (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_card_index    = (known after apply)
          + network_interface_id  = (known after apply)
        }

      ~ private_dns_name_options {
          ~ enable_resource_name_dns_a_record    = false -> (known after apply)
          ~ enable_resource_name_dns_aaaa_record = false -> (known after apply)
          ~ hostname_type                        = "ip-name" -> (known after apply)
        }

      ~ root_block_device {
          ~ device_name           = "/dev/sda1" -> (known after apply)
          ~ encrypted             = false -> true # forces replacement
          ~ iops                  = 100 -> (known after apply)
          + kms_key_id            = (known after apply)
          - tags                  = {} -> null
          ~ throughput            = 0 -> (known after apply)
          ~ volume_id             = "vol-00843199c70df9adf" -> (known after apply)
          ~ volume_size           = 8 -> 50
            # (2 unchanged attributes hidden)
        }
    }

  # module.EC2_JENKINS_MASTER.aws_instance.this must be replaced
-/+ resource "aws_instance" "this" {
      ~ arn                                  = "arn:aws:ec2:us-east-1:878893543361:instance/i-029b502b35fd3248c" -> (known after apply)
      ~ associate_public_ip_address          = false -> true # forces replacement
      ~ availability_zone                    = "us-east-1a" -> (known after apply)
      ~ cpu_core_count                       = 1 -> (known after apply)
      ~ cpu_threads_per_core                 = 1 -> (known after apply)
      ~ disable_api_stop                     = false -> (known after apply)
      ~ disable_api_termination              = false -> (known after apply)
      ~ ebs_optimized                        = false -> (known after apply)
      - hibernation                          = false -> null
      + host_id                              = (known after apply)
      + host_resource_group_arn              = (known after apply)
      ~ iam_instance_profile                 = "ECRRegistryFullAccessEC2" -> (known after apply)
      ~ id                                   = "i-029b502b35fd3248c" -> (known after apply)
      ~ instance_initiated_shutdown_behavior = "stop" -> (known after apply)
      + instance_lifecycle                   = (known after apply)
      ~ instance_state                       = "stopped" -> (known after apply)
      ~ ipv6_address_count                   = 0 -> (known after apply)
      ~ ipv6_addresses                       = [] -> (known after apply)
      ~ monitoring                           = false -> (known after apply)
      + outpost_arn                          = (known after apply)
      + password_data                        = (known after apply)
      + placement_group                      = (known after apply)
      ~ placement_partition_number           = 0 -> (known after apply)
      ~ primary_network_interface_id         = "eni-0654a190329396b8f" -> (known after apply)
      ~ private_dns                          = "ip-192-168-48-91.ec2.internal" -> (known after apply)
      ~ private_ip                           = "192.168.48.91" -> (known after apply)
      + public_dns                           = (known after apply)
      + public_ip                            = (known after apply)
      ~ secondary_private_ips                = [] -> (known after apply)
      ~ security_groups                      = [] -> (known after apply)
      + spot_instance_request_id             = (known after apply)
      - tags                                 = {
          - "Name" = "Jenkins-Master"
        } -> null
      ~ tags_all                             = {
          - "Name"       = "Jenkins-Master" -> null
            # (2 unchanged elements hidden)
        }
      ~ tenancy                              = "default" -> (known after apply)
      + user_data                            = (known after apply)
      + user_data_base64                     = (known after apply)
        # (8 unchanged attributes hidden)

      ~ capacity_reservation_specification {
          ~ capacity_reservation_preference = "open" -> (known after apply)

          + capacity_reservation_target {
              + capacity_reservation_id                 = (known after apply)
              + capacity_reservation_resource_group_arn = (known after apply)
            }
        }

      ~ cpu_options {
          + amd_sev_snp      = (known after apply)
          ~ core_count       = 1 -> (known after apply)
          ~ threads_per_core = 1 -> (known after apply)
        }

      - credit_specification {
          - cpu_credits = "standard" -> null
        }

      + ebs_block_device {
          + delete_on_termination = (known after apply)
          + device_name           = (known after apply)
          + encrypted             = (known after apply)
          + iops                  = (known after apply)
          + kms_key_id            = (known after apply)
          + snapshot_id           = (known after apply)
          + tags                  = (known after apply)
          + throughput            = (known after apply)
          + volume_id             = (known after apply)
          + volume_size           = (known after apply)
          + volume_type           = (known after apply)
        }

      ~ enclave_options {
          ~ enabled = false -> (known after apply)
        }

      + ephemeral_block_device {
          + device_name  = (known after apply)
          + no_device    = (known after apply)
          + virtual_name = (known after apply)
        }

      + instance_market_options {
          + market_type = (known after apply)

          + spot_options {
              + instance_interruption_behavior = (known after apply)
              + max_price                      = (known after apply)
              + spot_instance_type             = (known after apply)
              + valid_until                    = (known after apply)
            }
        }

      ~ maintenance_options {
          ~ auto_recovery = "default" -> (known after apply)
        }

      ~ metadata_options {
          ~ http_endpoint               = "enabled" -> (known after apply)
          ~ http_protocol_ipv6          = "disabled" -> (known after apply)
          ~ http_put_response_hop_limit = 1 -> (known after apply)
          ~ http_tokens                 = "optional" -> (known after apply)
          ~ instance_metadata_tags      = "disabled" -> (known after apply)
        }

      + network_interface {
          + delete_on_termination = (known after apply)
          + device_index          = (known after apply)
          + network_card_index    = (known after apply)
          + network_interface_id  = (known after apply)
        }

      ~ private_dns_name_options {
          ~ enable_resource_name_dns_a_record    = false -> (known after apply)
          ~ enable_resource_name_dns_aaaa_record = false -> (known after apply)
          ~ hostname_type                        = "ip-name" -> (known after apply)
        }

      ~ root_block_device {
          ~ device_name           = "/dev/sda1" -> (known after apply)
          ~ encrypted             = false -> true # forces replacement
          ~ iops                  = 100 -> (known after apply)
          + kms_key_id            = (known after apply)
          - tags                  = {} -> null
          ~ throughput            = 0 -> (known after apply)
          ~ volume_id             = "vol-070e3f9c6d2037bd1" -> (known after apply)
          ~ volume_size           = 8 -> 50
            # (2 unchanged attributes hidden)
        }
    }

  # module.EKS.aws_eks_addon.coredns will be created
  + resource "aws_eks_addon" "coredns" {
      + addon_name                  = "coredns"
      + addon_version               = "v1.9.3-eksbuild.2"
      + arn                         = (known after apply)
      + cluster_name                = "eks-mvarela-io"
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags_all                    = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
    }

  # module.EKS.aws_eks_addon.ebs_csi will be created
  + resource "aws_eks_addon" "ebs_csi" {
      + addon_name                  = "aws-ebs-csi-driver"
      + addon_version               = "v1.23.0-eksbuild.1"
      + arn                         = (known after apply)
      + cluster_name                = "eks-mvarela-io"
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags_all                    = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
    }

  # module.EKS.aws_eks_addon.kube_proxy will be created
  + resource "aws_eks_addon" "kube_proxy" {
      + addon_name                  = "kube-proxy"
      + addon_version               = "v1.26.2-eksbuild.1"
      + arn                         = (known after apply)
      + cluster_name                = "eks-mvarela-io"
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags_all                    = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
    }

  # module.EKS.aws_eks_addon.vpc_cni will be created
  + resource "aws_eks_addon" "vpc_cni" {
      + addon_name                  = "vpc-cni"
      + addon_version               = "v1.12.5-eksbuild.2"
      + arn                         = (known after apply)
      + cluster_name                = "eks-mvarela-io"
      + configuration_values        = (known after apply)
      + created_at                  = (known after apply)
      + id                          = (known after apply)
      + modified_at                 = (known after apply)
      + resolve_conflicts_on_create = "OVERWRITE"
      + resolve_conflicts_on_update = "OVERWRITE"
      + tags_all                    = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
    }

  # module.EKS.aws_eks_cluster.this will be created
  + resource "aws_eks_cluster" "this" {
      + arn                   = (known after apply)
      + certificate_authority = (known after apply)
      + cluster_id            = (known after apply)
      + created_at            = (known after apply)
      + endpoint              = (known after apply)
      + id                    = (known after apply)
      + identity              = (known after apply)
      + name                  = "eks-mvarela-io"
      + platform_version      = (known after apply)
      + role_arn              = (known after apply)
      + status                = (known after apply)
      + tags_all              = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
      + version               = "1.28"

      + kubernetes_network_config {
          + ip_family         = (known after apply)
          + service_ipv4_cidr = (known after apply)
          + service_ipv6_cidr = (known after apply)
        }

      + vpc_config {
          + cluster_security_group_id = (known after apply)
          + endpoint_private_access   = true
          + endpoint_public_access    = true
          + public_access_cidrs       = (known after apply)
          + security_group_ids        = (known after apply)
          + subnet_ids                = [
              + "subnet-019ad86490acf3d5f",
              + "subnet-0412d625c123ec2dc",
              + "subnet-0b87fae3a859b1f9a",
            ]
          + vpc_id                    = (known after apply)
        }
    }

  # module.EKS.aws_eks_node_group.main will be created
  + resource "aws_eks_node_group" "main" {
      + ami_type               = "AL2_x86_64"
      + arn                    = (known after apply)
      + capacity_type          = (known after apply)
      + cluster_name           = "eks-mvarela-io"
      + disk_size              = (known after apply)
      + id                     = (known after apply)
      + instance_types         = [
          + "t3.medium",
        ]
      + node_group_name        = "eks-mvarela-io-node-group"
      + node_group_name_prefix = (known after apply)
      + node_role_arn          = (known after apply)
      + release_version        = (known after apply)
      + resources              = (known after apply)
      + status                 = (known after apply)
      + subnet_ids             = [
          + "subnet-019ad86490acf3d5f",
          + "subnet-0412d625c123ec2dc",
          + "subnet-0b87fae3a859b1f9a",
        ]
      + tags                   = {
          + "Name" = "eks-mvarela-io-node-group"
        }
      + tags_all               = {
          + "Name"       = "eks-mvarela-io-node-group"
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
      + version                = (known after apply)

      + launch_template {
          + id      = (known after apply)
          + name    = "mvarela-io-launch-template"
          + version = (known after apply)
        }

      + scaling_config {
          + desired_size = 2
          + max_size     = 3
          + min_size     = 2
        }

      + update_config {
          + max_unavailable            = (known after apply)
          + max_unavailable_percentage = (known after apply)
        }
    }

  # module.EKS.aws_iam_policy.ec2_full_access_policy will be created
  + resource "aws_iam_policy" "ec2_full_access_policy" {
      + arn         = (known after apply)
      + id          = (known after apply)
      + name        = "ec2-full-access-policy"
      + name_prefix = (known after apply)
      + path        = "/"
      + policy      = jsonencode(
            {
              + Statement = [
                  + {
                      + Action   = [
                          + "ec2:*",
                        ]
                      + Effect   = "Allow"
                      + Resource = "*"
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + policy_id   = (known after apply)
      + tags_all    = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
    }

  # module.EKS.aws_iam_role.eks_cluster will be created
  + resource "aws_iam_role" "eks_cluster" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "eks.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "eks-mvarela-io-cluster"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # module.EKS.aws_iam_role.eks_nodes will be created
  + resource "aws_iam_role" "eks_nodes" {
      + arn                   = (known after apply)
      + assume_role_policy    = jsonencode(
            {
              + Statement = [
                  + {
                      + Action    = "sts:AssumeRole"
                      + Effect    = "Allow"
                      + Principal = {
                          + Service = "ec2.amazonaws.com"
                        }
                    },
                ]
              + Version   = "2012-10-17"
            }
        )
      + create_date           = (known after apply)
      + force_detach_policies = false
      + id                    = (known after apply)
      + managed_policy_arns   = (known after apply)
      + max_session_duration  = 3600
      + name                  = "eks-mvarela-io-worker"
      + name_prefix           = (known after apply)
      + path                  = "/"
      + tags_all              = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
      + unique_id             = (known after apply)

      + inline_policy {
          + name   = (known after apply)
          + policy = (known after apply)
        }
    }

  # module.EKS.aws_iam_role_policy_attachment.aws_eks_cluster_policy will be created
  + resource "aws_iam_role_policy_attachment" "aws_eks_cluster_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSClusterPolicy"
      + role       = "eks-mvarela-io-cluster"
    }

  # module.EKS.aws_iam_role_policy_attachment.aws_eks_cni_policy will be created
  + resource "aws_iam_role_policy_attachment" "aws_eks_cni_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy"
      + role       = "eks-mvarela-io-worker"
    }

  # module.EKS.aws_iam_role_policy_attachment.aws_eks_worker_node_policy will be created
  + resource "aws_iam_role_policy_attachment" "aws_eks_worker_node_policy" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy"
      + role       = "eks-mvarela-io-worker"
    }

  # module.EKS.aws_iam_role_policy_attachment.ebs_full_access_policy_attachment will be created
  + resource "aws_iam_role_policy_attachment" "ebs_full_access_policy_attachment" {
      + id         = (known after apply)
      + policy_arn = (known after apply)
      + role       = "eks-mvarela-io-worker"
    }

  # module.EKS.aws_iam_role_policy_attachment.ec2_read_only will be created
  + resource "aws_iam_role_policy_attachment" "ec2_read_only" {
      + id         = (known after apply)
      + policy_arn = "arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly"
      + role       = "eks-mvarela-io-worker"
    }

  # module.EKS.aws_launch_template.this will be created
  + resource "aws_launch_template" "this" {
      + arn                    = (known after apply)
      + default_version        = (known after apply)
      + id                     = (known after apply)
      + latest_version         = (known after apply)
      + name                   = "mvarela-io-launch-template"
      + name_prefix            = (known after apply)
      + tags_all               = {
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
      + vpc_security_group_ids = (known after apply)

      + block_device_mappings {
          + device_name = "/dev/xvda"

          + ebs {
              + iops        = (known after apply)
              + throughput  = (known after apply)
              + volume_size = 80
              + volume_type = "gp3"
            }
        }

      + metadata_options {
          + http_endpoint               = (known after apply)
          + http_protocol_ipv6          = (known after apply)
          + http_put_response_hop_limit = (known after apply)
          + http_tokens                 = (known after apply)
          + instance_metadata_tags      = (known after apply)
        }
    }

  # module.EKS.aws_security_group.eks_cluster will be created
  + resource "aws_security_group" "eks_cluster" {
      + arn                    = (known after apply)
      + description            = "Cluster communication with worker nodes"
      + egress                 = (known after apply)
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = "eks-mvarela-io-cluster-sg-mvarela-io"
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name" = "eks-mvarela-io-cluster-sg-mvarela-io"
        }
      + tags_all               = {
          + "Name"       = "eks-mvarela-io-cluster-sg-mvarela-io"
          + "managed-by" = "terraform"
          + "owner"      = "Mateus Varela"
        }
      + vpc_id                 = "vpc-02e6278fee33b0e02"
    }

  # module.EKS.aws_security_group.eks_nodes will be created
  + resource "aws_security_group" "eks_nodes" {
      + arn                    = (known after apply)
      + description            = "Security group for all nodes in the cluster"
      + egress                 = [
          + {
              + cidr_blocks      = [
                  + "0.0.0.0/0",
                ]
              + description      = ""
              + from_port        = 0
              + ipv6_cidr_blocks = []
              + prefix_list_ids  = []
              + protocol         = "-1"
              + security_groups  = []
              + self             = false
              + to_port          = 0
            },
        ]
      + id                     = (known after apply)
      + ingress                = (known after apply)
      + name                   = "eks-mvarela-io-node-sg-mvarela-io"
      + name_prefix            = (known after apply)
      + owner_id               = (known after apply)
      + revoke_rules_on_delete = false
      + tags                   = {
          + "Name"                                 = "eks-mvarela-io-node-sg-mvarela-io"
          + "kubernetes.io/cluster/eks-mvarela-io" = "owned"
        }
      + tags_all               = {
          + "Name"                                 = "eks-mvarela-io-node-sg-mvarela-io"
          + "kubernetes.io/cluster/eks-mvarela-io" = "owned"
          + "managed-by"                           = "terraform"
          + "owner"                                = "Mateus Varela"
        }
      + vpc_id                 = "vpc-02e6278fee33b0e02"
    }

  # module.EKS.aws_security_group_rule.cluster_inbound will be created
  + resource "aws_security_group_rule" "cluster_inbound" {
      + description              = "Allow worker nodes to communicate with the cluster API Server"
      + from_port                = 443
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 443
      + type                     = "ingress"
    }

  # module.EKS.aws_security_group_rule.cluster_outbound will be created
  + resource "aws_security_group_rule" "cluster_outbound" {
      + description              = "Allow cluster API Server to communicate with the worker nodes"
      + from_port                = 1024
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65535
      + type                     = "egress"
    }

  # module.EKS.aws_security_group_rule.nodes will be created
  + resource "aws_security_group_rule" "nodes" {
      + description              = "Allow nodes to communicate with each other"
      + from_port                = 0
      + id                       = (known after apply)
      + protocol                 = "-1"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65535
      + type                     = "ingress"
    }

  # module.EKS.aws_security_group_rule.nodes_inbound will be created
  + resource "aws_security_group_rule" "nodes_inbound" {
      + description              = "Allow worker Kubelets and pods to receive communication from the cluster control plane"
      + from_port                = 1025
      + id                       = (known after apply)
      + protocol                 = "tcp"
      + security_group_id        = (known after apply)
      + security_group_rule_id   = (known after apply)
      + self                     = false
      + source_security_group_id = (known after apply)
      + to_port                  = 65535
      + type                     = "ingress"
    }

  # module.TRAEFIK.helm_release.this will be created
  + resource "helm_release" "this" {
      + atomic                     = false
      + chart                      = "traefik"
      + cleanup_on_fail            = false
      + create_namespace           = true
      + dependency_update          = false
      + disable_crd_hooks          = false
      + disable_openapi_validation = false
      + disable_webhooks           = false
      + force_update               = true
      + id                         = (known after apply)
      + lint                       = true
      + manifest                   = (known after apply)
      + max_history                = 0
      + metadata                   = (known after apply)
      + name                       = "traefik"
      + namespace                  = "traefik"
      + recreate_pods              = true
      + render_subchart_notes      = true
      + replace                    = false
      + repository                 = "https://traefik.github.io/charts"
      + reset_values               = false
      + reuse_values               = false
      + skip_crds                  = false
      + status                     = "deployed"
      + timeout                    = 300
      + values                     = []
      + verify                     = false
      + version                    = "21.1.0"
      + wait                       = true
      + wait_for_jobs              = false

      + set {
          + name  = "deployment.replicas"
          + value = "1"
        }
    }

Plan: 25 to add, 0 to change, 2 to destroy.

─────────────────────────────────────────────────────────────────────────────

Note: You didn't use the -out option to save this plan, so Terraform can't
guarantee to take exactly these actions if you run "terraform apply" now.
